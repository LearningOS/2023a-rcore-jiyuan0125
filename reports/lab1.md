## 功能

按照题目要求，实现了两个功能：

1. 在 TaskControlBlock 中添加了 `first_syscall_time` 和 `syscall_times` 两个成员，分别记录进程第一次调用系统调用的时间和调用系统调用的次数。并在`syscall`函数中对其进行更新。
2. 新增加一个系统调用 `sys_task_info`，用于获取进程的系统调用信息。

## 问答题

一. 测试三个出错程序

当前使用的 sbi 版本: RustSBI-QEMU Version 0.2.0-alpha.2。
`ch2b_bad_address` 应用由于访问了一个非法的内存地址，触发了`Exception::StoreFault`异常。内核将其终止。
`ch2b_bad_instructions` 应用由于使用了未授权的指令，触发了`Exception::IllegalInstruction`异常。内核将其终止。
`ch2b_bad_register` 应用由于访问了未授权的寄存器，触发了`Exception::IllegalInstruction`异常。内核将其终止。

二. 深入理解 trap.S 中两个函数 `__alltraps` 和 `__restore` 的作用

1. 刚进入 `__restore` 时，`a0` 代表将要运行的应用的 `TaskContext`。 使用 `__restore` 的两个场景是首次运行应用和从内核返回到用户态时。
  
2. `sstatus`（状态寄存器）: `sstatus`寄存器用于保存当前处理器的状态信息。其中，`SIE`字段表示是否允许硬件中断，`SPP`字段表示中断前的模式。在用户态陷入到内核态时，`SPP`字段会被设置为用户模式，表示是从用户态陷入的。
`sepc`（程序异常计数器）: `sepc`用于保存中断或异常发生时的程序计数器（`PC`）值。当内核处理完异常以后，使用`sret`指令将`sepc`的值赋给`pc`，从而恢复到中断或异常发生时的指令处继续执行。
sscratch（临时寄存器）: sscratch是一个通用的临时寄存器。在处理中断或异常时，本章使用它用来交换内核栈和用户栈。

3. x2 是栈指针，需要最后处理，过早取出会导致栈指针错误。 x4 是线程指针寄存器，除非我们手动出于一些特殊用途使用它，否则一般也不会被用到。

4. 这行执行以后 sp 指向用户栈栈顶, sscratch 内核栈栈顶。

5. sret 切换到用户态，将 sepc 的值赋给 pc，从而恢复到中断或异常发生时的指令处继续执行。

6. 执行以后 sp 指向内核栈栈顶, sscratch 指向用户栈栈顶。

7. 是通过 ecall 指令发生的。 ecall 指令会触发一个异常，内核会根据异常号来判断是系统调用还是其他异常。 
  

## 荣誉准则sstatus（状态寄存器）: sstatus寄存器用于保存当前处理器的状态信息。其中，SIE字段表示是否允许硬件中断，SPP字段表示中断前的模式。在用户态，SPP字段会被设置为用户模式，以指示当前处于用户态。[1]

我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
